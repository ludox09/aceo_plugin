# -*- coding: utf-8 -*-
"""
/***************************************************************************
 aceo
                                 A QGIS plugin
 GUI tools for AgriCarbon-EO processing chain
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-05-25
        git sha              : $Format:%H$
        copyright            : (C) 2021 by CESBIO
        email                : ludox09@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QObject,Qt,QDate
from qgis.PyQt.QtGui import QIcon,QColor
from qgis.PyQt.QtWidgets import QAction, QGraphicsScene, QTableWidgetItem
from qgis.core import QgsProject,QgsGeometry,QgsPointXY
from qgis.gui import QgsMapCanvas,QgsMapTool,QgsMapToolEmitPoint,QgsMapToolIdentify,QgsVertexMarker


# Initialize Qt resources from file resources.py
from .resources import *
import traceback

# Import the code for the DockWidget
from .aceo_plugin_dockwidget import aceoDockWidget
import os.path
from math import floor

import glob
import numpy as np
import datetime
import matplotlib.pyplot as plt
#from matplotlib.backends.backend_qt4agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar



class aceo:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'aceo_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&AgriCarbon-EO Plugin')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'aceo')
        self.toolbar.setObjectName(u'aceo')

        #print "** INITIALIZING aceo"

        self.pluginIsActive = False
        self.dockwidget = None


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('aceo', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/aceo_plugin/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u''),
            callback=self.run,
            parent=self.iface.mainWindow())

    #--------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING aceo"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD aceo"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&AgriCarbon-EO Plugin'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    #--------------------------------------------------------------------------

    def Update_Graph(self):
        try:
            paths,datesdict,vari,outs,prosail,prosail_dos = self.get_paths(self.experiment_file,self.wz,self.pix)
            self.make_uncertainty_plot(datesdict,vari,outs,prosail,prosail_dos,self.wz,self.pix)
        except:
            traceback.print_exc()
            for i in range(len(self.plots)):
                item = self.plots.pop(-1)
                item.remove()  
            plt.title("Invalid pixel",color='r')
            #self.error_string = plt.text(2,3.5,"Invalid pixel",color='r', size = 50 )
            self.figure.canvas.draw()

    def val_change(self):
       
        print(self.dockwidget.datemin.date(),self.dockwidget.datemax.date())
        self.Update_Graph()


        # Update comboBox and save value
        #combo = self.dockwidget.sender()
        #selectedLayerIndex = combo.currentIndex()
        #selectedLayer = self.layers[selectedLayerIndex].name()
        #self.saveSettings()


    def clickedOnMap(self, point, button):
        # Place marker
        #self.M1.setCenter(point)

        self.point = point

        # Getting appropritate layers
        self.layer = self.iface.activeLayer()
        
        # Getting raster info
        data_provider = self.layer.dataProvider()
        
        # Manage canvas coordinate
        X1,Y1,col1,row1 = self.Coordinates(data_provider,point)
        
        # Getting pixel dat
        nband, profile = self.get_bands(data_provider,point)
        profile = profile.astype(np.int)

        self.wz = profile[0]
        self.pix = profile[2]
        self.experiment_file = self.dockwidget.runpath.filePath()
        self.Update_Graph()



    def Coordinates(self,data_provider,point):
        extent = data_provider.extent()
        width = data_provider.xSize() if data_provider.capabilities() & data_provider.Size else 1000
        height = data_provider.ySize() if data_provider.capabilities() & data_provider.Size else 1000
        xres = extent.width() / width
        yres = extent.height() / height

        if extent.xMinimum() <= point.x() <= extent.xMaximum() and \
            extent.yMinimum() <= point.y() <= extent.yMaximum():
            col = int(floor((point.x() - extent.xMinimum()) / xres))
            row = int(floor((extent.yMaximum() - point.y()) / yres))
        else:
            col = -1
            row = -1

        X = point.x()
        Y = point.y()

        return X,Y,col,row



    def get_bands(self,data_provider,point):
        nband = data_provider.bandCount()
        val = []
        for i in range(nband):
            v,res = data_provider.sample(point,i+1)
            val.append(v)
        val = np.array(val)
        return nband,val



    def get_paths(self,experiment_file,wz,pixel):
       
        """
     
        Parameters:
        ----------
        experiment_file : str,
            name of an AgriCarbon-EO prosail+SAFYE-CO2 experiment
           
        wz : int
            weather zone
           
        pixel : int
            simultion pixel number inside theweather zone mz
           
        varname : str
            SAFYE-CO2 variable name
           
           
            gets all the relevant data & paths of a SAFYE-CO2 experiment
     
        Returns:
        dict "path" contaning the run file name "run_file",SAFYE-CO2 loglikelyhood paths "outs", the SAFYE-CO2 output variables ,
              prosail outputs "prosail_per_meteo", datesdict "datesdict" and spadict "spadict" .
             
       
        """
       
        paths={}
        experiment_file.split('/')
        run_file=experiment_file+"/../"
        #for f in experiment_file.split('/')[:-1]:
        #    run_file=run_file+f+'/' 
        paths['run_file']=run_file
        paths['outs']=glob.glob(experiment_file+'/SAFYE_CO2_out/*')
        paths['prosail_per_meteo'] =glob.glob(run_file+'/prosail_permeteo/*')
        paths['varis']=glob.glob(experiment_file+'/SAFYE_CO2_LUT_vari/*')
        paths['datesdict']=run_file+'/datesdict.npy'
        paths['spadict']=run_file+'/spadict.npy'
     
      
        wz_str=('%03d'%(wz))
       
        datesdict = np.load(paths['datesdict'],allow_pickle=True).item()
        #print(datesdict['str_date'])
        #print(datesdict['str_date'][0])
        #print(datesdict['str_date'][-1])

        #self.dockwidget.datemin.setDate(QDate.fromString(str(datesdict['str_date'][0]),"yyyyMMdd"))
        #self.dockwidget.datemax.setDate(QDate.fromString(str(datesdict['str_date'][-1]),"yyyyMMdd"))

        vari=np.load([v for v in paths['varis'] if wz_str in v][0],allow_pickle=True).item()
        outs=np.load([v for v in paths['outs'] if wz_str in v][0],allow_pickle=True).item()
        prosail=np.load([v for v in paths['prosail_per_meteo'] if wz_str in v][0],allow_pickle=True).item()['vari']

        if self.varlist_obs != prosail.keys():
            self.varlist_obs = prosail.keys()
            self.dockwidget.varname_obs.clear()
            self.dockwidget.varname_obs.addItems(self.varlist_obs)
        self.varname_obs = self.dockwidget.varname_obs.currentText()


        if self.varlist_sim != vari.keys():
            self.varlist_sim = vari.keys()
            self.dockwidget.varname_sim.clear()
            self.dockwidget.varname_sim.addItems(self.varlist_sim)
        self.varname_sim = self.dockwidget.varname_sim.currentText()

        prosail = prosail[self.varname_obs]['SENTINEL2']
        prosail_dos=[datesdict['str2dos'][d] for d in prosail['dates']]
        vari = vari[self.varname_sim]

        return(paths,datesdict,vari,outs,prosail,prosail_dos)
     
    
    def make_uncertainty_plot(self,datesdict,vari,outs,prosail,prosail_dos,wz,pixel):
        """
        
     
         Parameters
         ----------
         datesdict : dict
              dictionary containing  all the temporal data of an AgriCarbon-EO
              simulation
              
         vari : dict,
             dictionary containing  all SAFYE-CO2 output variables for a weather
             zone
            
         outs : dict
             dictionary containing the output loglikelyhood and indexes ouf the n
             best solutions in the LUT
        
         prosail : dict
             dictionary containing the output mean and std for the output variables
             of prosail aver a weather zone
          
         prosail_dos :
             list, days of simulation of the prosail outputs
          
         DESCRIPTION:
             This function draws the weigthed ensemble a posteriori for a SAFYE-CO2
             experiment for the [mz,pixel] simulation point for tyhe variable
             varname
     
         Returns
         -------
         None.
     
         """
                    
        w=outs['weigths'][:,pixel]
       
        w=np.exp(w-np.nanmax(w,axis=0))
        w0=w/w.sum(axis=0)
        w=(w0-np.min(w))/(np.max(w0)-np.min(w0))
       
        #plt.figure(figsize=(20,5))
       
        #plt.ylabel('a posteriori \n'+varname,fontsize=20)
        #plt.xlabel('date',fontsize=20)
   
        for i in range(len(self.plots)):
            item = self.plots.pop(-1)
            item.remove()  

        for sol in np.arange( outs['LUT_indexes'].shape[0]):
            if np.greater(w[sol],0):
                p, = plt.plot(vari[ outs['LUT_indexes'][sol,pixel].astype(int),:].T,color=[1,0,0],alpha=w[sol]/4)
                self.plots.append(p)
        maxlike=np.argmax(w)
        p, = plt.plot(vari[ outs['LUT_indexes'][maxlike,pixel].astype(int),:].T,color=[0.2,0,0.7])
        self.plots.append(p)
        for j in np.arange(len(prosail_dos)):
           d     = np.array(prosail_dos).flatten()[j]
           std   = np.clip(prosail['std'][:,pixel],0.2,100)
           negsi = (prosail['mean'][:,pixel].flatten()-std.flatten())[j]
           possi = (prosail['mean'][:,pixel].flatten()+std.flatten())[j]

           p, = plt.plot((d,d),(negsi,possi),color=[0.4,0.6,0.3],linewidth=2,alpha=0.6)
           self.plots.append(p)
           p, = plt.plot(d,prosail['mean'][:,pixel].flatten()[j],'.',color=[0.2,0.4,0.1],markersize=12,alpha=0.8)
           self.plots.append(p)
       
        locs=np.where(np.equal(np.mod(datesdict['str_date'],100),1))[0]
        months=np.round(datesdict['str_date'][locs]/100).astype(int)
         
        monthsstr=[]
        for m in months:
            monthsstr.append(str(m)[:4]+'/'+str(m)[4:])

        plt.xticks(locs,monthsstr, rotation=45,fontsize=10)
        plt.yticks(fontsize=10)

        plt.title('zone '+str(wz)+'_ pixel '+str(pixel),color='k')
        plt.axis('tight')
        plt.ylabel('a posteriori \n'+self.varname_sim,fontsize=10) 
        plt.xlabel('date',fontsize=10)

        if self.varname_sim =='GLA':
            plt.ylim(0,7)
        else:
            plt.ylim(np.min(vari[outs['LUT_indexes'][:,pixel]]),np.max(vari[outs['LUT_indexes'][:,pixel]]))

        self.figure.canvas.draw()
     

    def saveSettings(self):
        with open(self.plugin_dir + "/settings.txt","w") as f:
            #f.write(str(self.dockwidget.comboBox_N0.currentIndex())+"\n")
            #.write(str(self.dockwidget.comboBox_N1.currentIndex())+"\n")
            #.write(str(self.dockwidget.comboBox_raster.currentIndex())+"\n")
            f.write(self.dockwidget.runpath.filePath())

    def pick(self):
        self.emitPoint = QgsMapToolEmitPoint(self.canvas)
        self.canvas.setMapTool(self.emitPoint)
        self.emitPoint.canvasClicked.connect(self.clickedOnMap)

    def initialization(self):
        # Get settings file parameter
        
        #l0 = 0
        #l1 = 1
        #l2 = 2
        runpath = ""
        with open(self.plugin_dir + "/settings.txt","r") as f:
            try:
                #l0 = int(f.readline())
                #l1 = int(f.readline())
                #l2 = int(f.readline())
                runpath = f.readline().strip()
            except:
                pass
   
        # Declare parameter widgets
  
        self.varlist_obs = ["GLA"]
        self.varlist_sim = ["GLA"]

        self.dockwidget.varname_obs.clear()
        self.dockwidget.varname_sim.clear()
        #self.dockwidget.varname.addItems([var for var in varlist])
        self.dockwidget.varname_obs.addItems(self.varlist_obs)
        self.dockwidget.varname_sim.addItems(self.varlist_obs)
        self.dockwidget.varname_obs.setCurrentIndex(0)
        self.dockwidget.varname_sim.setCurrentIndex(0)
        self.dockwidget.varname_obs.currentIndexChanged.connect(self.val_change)
        self.dockwidget.varname_sim.currentIndexChanged.connect(self.val_change)

        ## Initialize parameter widgets
        #self.dockwidget.comboBox_N0.setCurrentIndex(l0)
        #self.dockwidget.comboBox_N1.setCurrentIndex(l1)
        #self.dockwidget.comboBox_raster.setCurrentIndex(l2)
        self.dockwidget.runpath.setFilePath(runpath)

        # Add signal handle to parameter widgets
        #self.dockwidget.comboBox_N0.currentIndexChanged.connect(self.comboBox_change)
        #self.dockwidget.comboBox_N1.currentIndexChanged.connect(self.comboBox_change)
        #self.dockwidget.comboBox_raster.currentIndexChanged.connect(self.comboBox_change) 
        self.dockwidget.runpath.fileChanged.connect(self.saveSettings)
        self.dockwidget.pickmap.clicked.connect(self.pick)

        #self.dockwidget.datemin.dateChanged.connect(self.val_change)
        #self.dockwidget.datemax.dateChanged.connect(self.val_change)

        # Init plot area
        self.figure = plt.figure(figsize = (15,3))
     
        self.dockwidget.runpath.setStorageMode(1)
        self.varname_obs = self.dockwidget.varname_obs.currentText()
        self.varname_sim = self.dockwidget.varname_sim.currentText()

        plt.ylabel('a posteriori \n'+self.varname_sim,fontsize=10) 

        plt.xlabel('date',fontsize=10)
        plt.ylim(0,7)

        
        self.plots = []
        p, = plt.plot([0,0],[1,1], color = 'g') # NOTE: becarefull with the syntax. there is a comma.
        self.plots.append(p)
   
        # Apply date on plot
        #self.update_dates()
   
        self.figure.tight_layout()
   
        self.scene = QGraphicsScene(self.dockwidget)
        window = FigureCanvas(self.figure)
        self.scene.addWidget(window)
        self.dockwidget.graphicsView.setScene(self.scene)
        self.dockwidget.show()

        self.figure.canvas.draw()
        self.pick()

    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True

            #print "** STARTING aceo"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = aceoDockWidget()

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.TopDockWidgetArea, self.dockwidget)
            self.dockwidget.show()

            self.canvas = self.iface.mapCanvas()
            self.initialization()

